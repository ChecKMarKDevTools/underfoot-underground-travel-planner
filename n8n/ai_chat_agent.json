{
  "name": "ai_chat_agent",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "needsFallback": true,
        "options": {
          "systemMessage": "<instructions>\n<persona>\nYou are Stonewalker: a mystical, concise, and helpful guide who uncovers hidden, interesting places. Speak with clarity, wisdom, and brevity.\n</persona>\n\n<goal>\nHelp the user discover unique places of interest using available tools. If the user’s input is incomplete or unnormalized, make an educated guess, normalize as needed, or ask a clarifying question if confidence is low.  \nAlways output a persona-driven message to the user and a JSON array of relevant items, each with a decimal “Stonewalker Stars” rating (your confidence they’ll enjoy it).\n</goal>\n\n<steps>\n1. Assess if the input contains both a valid intent and a valid location (or if either must be guessed/clarified).\n  - You may use your history as context to determine what the user is trying to communicate.\n2. Normalize both intent and location for tool use.  \n   - If you must guess, be explicit and acknowledge this in your response.\n3. Search using available tools.  \n   - If no relevant results, inform the user and help broaden their search.\n4. For each result, assign a “Stonewalker Stars” score (0–1) using the official scoring formula.\n   - Drop any result that scores 0 for relevance.\n5. Return all relevant data in the structured response. If one or more items do not apply, simply output an empty array, object, or empty string to ensure you pass validation.\n</steps>\n\n<tools class=\"constraints\">\nYou should always attempt to call every tool with a timeout set. Do not wait for an extended amount of time for results to return but you should at least try to retrieve some data from each tool.\n\nWhen outputting data from multiple tools, be sure that it is all in a single list. The results should be normalized so you can include the basic requirements and additional extras that are relevant.\n</tools>\n\n\n<user-input-normalization class=\"constraints\">\nNever pass user input directly to any tool. Always normalize first.  \nIf intent is unclear, do your best but acknowledge the guess and ask for clarification.\n</user-input-normalization>\n\n<intent-normalization class=\"constraints\">\nThe user’s “intent” may be any noun or adjective-noun (e.g., “mystical scary graveyards”).  \n- Encourage unique and specific requests, but preserve their exact wording (adjectives and noun together as a single string).\n- Only modify to clarify or combine, never split into separate keywords.\n<example>\nUser: “mystical scary graveyards”  \nNormalized: “mystical scary graveyards”\n</example>\n</intent-normalization>\n\n<location-normalization class=\"constraints\">\nNormalize any location input (city, region, or coordinates) to: `<city>, <state code>, <country>`.  \nIf needed, infer from common abbreviations or misspellings.\n<example>\nUser: “Atl”  \nNormalized: “Atlanta, GA, United States”\n</example>\n</location-normalization>\n\n<output class=\"constraints\">\nFollowing the structured output example, always output at minimum:  \n1. Your concise, mystical message to the user (persona-driven)  \n2. The user's 'intent' after you parsed so it can be stored in the cache\n3. The normalized 'location' given by the user to store in the cache.\n4. A JSON array of areas of interest as returned by the tool, each with a decimal `score` in [0,1] representing your “Stonewalker Stars” confidence in their fit for the user’s intent. Listed with most relevant first.\n\n<example-schema>\n{\n  \"user_intent\": \"quiet, beach-like spots to sit by the water\",\n  \"user_location\": \"Tallapoosa, GA\",\n  \"response\": \"Tallapoosa isn’t coastal, but you’ve got mellow shorelines within a day-use drive. Try Yellowjacket Beach on West Point Lake for a true sand-under-toes vibe, or Lake Harding’s small sandy pull-offs for a quieter read-by-the-water afternoon. Pack snacks, bug spray, and cash for day-use where posted.\",\n  \"places\": [\n    {\n      \"name\": \"Yellowjacket Beach, West Point Lake\",\n      \"description\": \"Managed day-use area with a sandy swim beach, restrooms, and picnic tables on a large reservoir.\",\n      \"address\": \"Yellowjacket Creek Recreation Area, LaGrange, GA 30240\",\n      \"city\": \"LaGrange\",\n      \"state\": \"GA\",\n      \"country\": \"US\",\n      \"coordinates\": { \"lat\": 32.935, \"lng\": -85.129 },\n      \"url\": \"https://example.com/west-point-lake-yellowjacket\",\n      \"tags\": [\"lake\", \"swim beach\", \"picnic\", \"family-friendly\"],\n      \"stonewalker_stars\": 4.4,\n      \"confidence\": 0.87,\n      \"source\": \"google_places\",\n      \"source_id\": \"west_point_yellowjacket_beach\",\n      \"cached_at\": \"2025-09-01T01:10:00Z\"\n    },\n    {\n      \"name\": \"Lake Harding (select sandy pull-offs)\",\n      \"description\": \"Reservoir on the Chattahoochee with small informal sandy edges; good for low-key shoreline lounging.\",\n      \"address\": \"Lake Harding, GA/AL border\",\n      \"city\": \"Salem\",\n      \"state\": \"AL\",\n      \"country\": \"US\",\n      \"coordinates\": { \"lat\": 32.682, \"lng\": -85.125 },\n      \"url\": \"https://example.com/lake-harding-shore\",\n      \"tags\": [\"lake\", \"quiet\", \"shore access\"],\n      \"stonewalker_stars\": 3.9,\n      \"confidence\": 0.78,\n      \"source\": \"google_maps\",\n      \"source_id\": \"lake_harding_misc_shore\",\n      \"cached_at\": \"2025-09-01T01:10:00Z\"\n    }\n  ]\n}\n</example-schema>\n</output>\n\n<stonewalker-scoring class=\"instructions\">\nUNDERFOOT SCORING (always run after retrieving items)\n- For each item, calculate a `score` in [0,1] using:\n  - **relevance** ([0,1]): Text match to user intent + location in title/description/categories.\n  - **distance_component** ([0,1]):\n      - 0–5 miles: ~1.0\n      - 5–15 miles: ~0.7\n      - 15–35 miles: ~0.4\n      - >35 miles: ~0.15\n      - missing: 0.5\n  - **app_fit** ([0,1]):\n      - High (0.8–1.0): public, safe, experience-forward (tours, landmarks, museums, parks, historic sites, oddities, festivals, etc.)\n      - Low (0–0.2): private, unsafe, services (funeral homes, hospitals, offices, explicit/adult, logistics, generic retail, etc.)\n      - Special: Cemeteries medium if historic/tour; low otherwise.\n- Final: `score = clamp01(0.5*relevance + 0.2*distance_component + 0.3*app_fit)`\n- ALWAYS attach `score` to each item (do not invent items/fields, use URL as key).\n- Consistently apply rules and do not return results that score 0.\n</stonewalker-scoring>\n</instructions>\n",
          "maxIterations": 5,
          "returnIntermediateSteps": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [72, 1144],
      "id": "0968cb4e-b08c-4ea0-8316-492b853dc8ee",
      "name": "chat_agent",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {
          "maxTokens": 512,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [-112, 1368],
      "id": "c8b14b74-d852-4452-91d3-e9eb0dd09b1e",
      "name": "gpt_4.1_mini",
      "credentials": {
        "openAiApi": {
          "id": "wu29aQSrIIZ9BvRS",
          "name": "openai_primary_api_key"
        }
      }
    },
    {
      "parameters": {
        "message": "={{ $json.output }}\n\n---\n\n",
        "waitUserReply": false,
        "options": {
          "memoryConnection": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chat",
      "typeVersion": 1,
      "position": [1056, 784],
      "id": "268279a9-5f55-4737-a24e-5786bca7f3bd",
      "name": "respond_to_chat",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {
          "maxTokens": 512,
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [16, 1368],
      "id": "6d4b1c1b-6629-4e06-8b19-c20a10925e97",
      "name": "gpt_4.1_full",
      "credentials": {
        "openAiApi": {
          "id": "wu29aQSrIIZ9BvRS",
          "name": "openai_primary_api_key"
        }
      }
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "wRCvCmRGcILIoLjy",
          "mode": "list",
          "cachedResultName": "Underfoot — wf_error_notifications"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "json": "={{ $input }}",
            "callingFlow": "={{ $workflow }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "json",
              "displayName": "json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "object"
            },
            {
              "id": "callingFlow",
              "displayName": "callingFlow",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [1120, 1096],
      "id": "59262f79-432b-403d-b51a-3265e55118f0",
      "name": "call_discord_error_notifier",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "public": true,
        "initialMessages": "Welcome to Underfoot 🪨 Where are you headed and what do you hope to uncover there? The stones will tell us exactly where to go.",
        "options": {
          "inputPlaceholder": "I'd love to find the oldest grave that exists in Salem.",
          "subtitle": "Uncover hidden gems with the legendary Stonewalker",
          "title": "Underfoot",
          "responseMode": "responseNodes"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [-336, 1144],
      "id": "a982f942-cc47-466f-9a89-c710ed0244d6",
      "name": "hosted_chat_trigger",
      "webhookId": "d92bc454-8f78-4471-ae25-ffa0c9bb87b3",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "description": "Use this tool to search Google for web pages, places, or events matching the user’s query. Provide only when the user requests information that can be found through a general web search (news, local businesses, things to do, etc.). Do not use for specialized databases or tasks requiring structured/official data.",
        "workflowId": {
          "__rl": true,
          "value": "TjJFvBLuhBlEO3c8",
          "mode": "list",
          "cachedResultName": "Underfoot — wf_maps_serp_backup_data"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "intent": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('intent', ``, 'string') }}",
            "location": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('location', ``, 'string') }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "intent",
              "displayName": "intent",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "location",
              "displayName": "location",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [272, 1368],
      "id": "32721a92-725d-4fb7-be5e-7af958305e87",
      "name": "call_google_serp"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "af58e54e-336c-4a32-bda0-430b6e447076",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [-336, 560],
      "id": "ffbfbbc4-048f-45af-8db6-39891d4cb84a",
      "name": "webhook_trigger",
      "webhookId": "af58e54e-336c-4a32-bda0-430b6e447076",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "useCustomSchema": true,
        "schema": "underfoot",
        "operation": "getAll",
        "tableId": "search_cache",
        "limit": 10,
        "filters": {
          "conditions": [
            {
              "keyName": "title",
              "condition": "ilike",
              "keyValue": "=*{{ $fromAI('title', 'the title of a previouss search result') }}*"
            },
            {
              "keyName": "description",
              "condition": "ilike",
              "keyValue": "=*{{ $fromAI('description', 'exactly one keyword to search the description for') }}*"
            },
            {
              "keyName": "user_intent",
              "condition": "ilike",
              "keyValue": "=*{{ $fromAI('intent', 'exactly one keyword to search intent for') }}*"
            },
            {
              "keyName": "user_location",
              "condition": "ilike",
              "keyValue": "=*{{  $fromAI('location', 'the smallest part of a location you have to search for') }}*"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [400, 1368],
      "id": "22ad8324-0e1e-461c-b417-b3c2bce2e77b",
      "name": "search_cache",
      "credentials": {
        "supabaseApi": {
          "id": "NabDZqnQNq4nPLYM",
          "name": "supabase_anon_key"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [-336, 336],
      "id": "b21695e4-2b41-44c9-9ae3-7f819bbab2e1",
      "name": "respond_to_webhook"
    },
    {
      "parameters": {
        "contextWindowLength": 12
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [144, 1368],
      "id": "4cba12d8-ccd9-4c83-9850-34bc6dc71c2a",
      "name": "agent_memory"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d31c30b9-76e3-4934-a4a2-a23c9faa8207",
              "name": "sessionId",
              "value": "={{ uuid() }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-112, 560],
      "id": "d606ed97-54dd-4aff-a2cd-8de35ebba64f",
      "name": "assign_sessionId"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Normalizer for agent output (object with user_intent, user_location, response, and places)\n// Outputs: { response, items, user_intent, user_location, source, error }\n\nconst input = $json || {};\nconst outputObj = input?.output || input?.raw?.output || {};\n\n// 1. Handle stringified output (rare fallback)\nlet output = outputObj;\nif (typeof output === \"string\") {\n  try {\n    output = JSON.parse(output);\n  } catch {\n    output = {};\n  }\n}\n\n// 2. Pull fields directly\nconst user_intent    = output?.user_intent    ?? null;\nconst user_location  = output?.user_location  ?? null;\nconst response       = output?.response       ?? null;\nconst items          = Array.isArray(output?.places) ? output.places : [];\n\n// 3. Fallbacks from intermediateSteps if missing\nif ((!user_intent || !user_location) && Array.isArray(input?.intermediateSteps)) {\n  for (const step of input.intermediateSteps) {\n    const toolInput = step?.action?.toolInput;\n    if (toolInput) {\n      if (!user_intent && toolInput.intent) user_intent = toolInput.intent;\n      if (!user_location && toolInput.location) user_location = toolInput.location;\n      if (user_intent && user_location) break;\n    }\n  }\n}\n\n// 4. Output clean structure\nreturn {\n  response,\n  items,\n  user_intent,\n  user_location,\n  source: \"format-normalizer\",\n  error: null\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [608, 1144],
      "id": "0d84aaca-ab8f-47dd-b5ab-08c9a949a19d",
      "name": "normalize_output",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Code node — Run Once for All Items\n// Input: items where each item.json has { output: { user_intent, user_location, response, places[] } }\n// Output: ARRAY with a single item: { json: { text: \"<prettified markdown>\" } }\n\nconst items = $input.all();\n\n// ---- helpers ----\nconst asArray = (v) => Array.isArray(v) ? v : (v == null ? [] : [v]);\nconst safe = (s) => (s ?? \"\").toString().trim();\nconst fmtPct = (n) => (typeof n === \"number\" && isFinite(n)) ? `${Math.round(n * 100)}%` : \"—\";\nconst fmtDate = (iso) => {\n  if (!iso) return \"—\";\n  const d = new Date(iso);\n  return isNaN(d.getTime()) ? \"—\" : d.toISOString().slice(0, 10);\n};\nconst fmtCoords = (c) => (c && typeof c.lat === \"number\" && typeof c.lng === \"number\")\n  ? `${c.lat.toFixed(5)}, ${c.lng.toFixed(5)}`\n  : \"—\";\n\nfunction extractOutputs(allItems) {\n  const outs = [];\n  for (const it of allItems) {\n    const j = it?.json ?? {};\n    if (j.output && typeof j.output === \"object\") outs.push(j.output);\n    // also allow the case where the object itself *is* the output\n    else if (j.user_intent || j.places || j.response) outs.push(j);\n    // allow nested arrays (rare)\n    else if (Array.isArray(j)) {\n      for (const maybe of j) {\n        if (maybe?.output) outs.push(maybe.output);\n      }\n    }\n  }\n  return outs;\n}\n\nfunction formatPlace(p, idx) {\n  const name = safe(p.name) || `Place ${idx + 1}`;\n  const addr = safe(p.address);\n  const cityState = [safe(p.city), safe(p.state)].filter(Boolean).join(\", \");\n  const country = safe(p.country);\n  const locLine = [addr, [cityState, country].filter(Boolean).join(\", \")].filter(Boolean).join(\" — \");\n  const stars = fmtPct(p.stonewalker_stars ?? p.confidence);\n  const source = safe(p.source);\n  const url = safe(p.url);\n  const coords = fmtCoords(p.coordinates);\n  const cached = fmtDate(p.cached_at);\n  const tags = Array.isArray(p.tags) && p.tags.length ? p.tags.join(\", \") : \"—\";\n\n  const lines = [];\n  lines.push(`- **${name}**  \\n  Stonewalker Stars: **${stars}**`);\n  if (locLine) lines.push(`  Location: ${locLine}`);\n  if (coords !== \"—\") lines.push(`  Coords: ${coords}`);\n  if (source) lines.push(`  Source: ${source}`);\n  if (url) lines.push(`  Link: ${url}`);\n  if (tags !== \"—\") lines.push(`  Tags: ${tags}`);\n  if (cached !== \"—\") lines.push(`  Cached: ${cached}`);\n  const desc = safe(p.description);\n  if (desc) lines.push(`  _${desc}_`);\n  return lines.join(\"\\n\");\n}\n\nconst outputs = extractOutputs(items);\n\nif (!outputs.length) {\n  return [{ json: { text: \"No results to display.\" } }];\n}\n\nconst chunks = [];\n\nfor (const out of outputs) {\n  const header = `### ${safe(out.user_intent) ? `Intent: **${safe(out.user_intent)}**` : \"Result\"}  \\n${safe(out.user_location) ? `Location: **${safe(out.user_location)}**` : \"\"}`.trim();\n  const prose = safe(out.response);\n  const places = asArray(out.places)\n    .filter(p => p && typeof p === \"object\")\n    .sort((a, b) => (b.stonewalker_stars ?? b.confidence ?? 0) - (a.stonewalker_stars ?? a.confidence ?? 0));\n\n  chunks.push(header || \"### Result\");\n  if (prose) chunks.push(`\\n${prose}\\n`);\n\n  if (places.length) {\n    chunks.push(\"**Top Picks**\");\n    for (let i = 0; i < places.length; i++) {\n      chunks.push(formatPlace(places[i], i));\n    }\n  } else {\n    chunks.push(\"_No specific places were returned._\");\n  }\n}\n\n// Return a single chat-friendly markdown blob\nreturn [\n  {\n    json: {\n      text: chunks.join(\"\\n\\n\")\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [832, 832],
      "id": "d95e7934-0947-4909-ab08-41922a2eaf61",
      "name": "pretty_print_results",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "IAKagbbjRUADr5n4",
          "mode": "list",
          "cachedResultName": "Underfoot — wf_update_all_caches"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "intent": "={{ $json.intent }}",
            "location": "={{ $json.intent }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "intent",
              "displayName": "intent",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "location",
              "displayName": "location",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [832, 1360],
      "id": "6eb208f6-b242-4611-ad1b-070d56d8268d",
      "name": "send_off_whispers_in_the_ether",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "useCustomSchema": true,
        "schema": "underfoot",
        "tableId": "rpc/merge_search_cache",
        "dataToSend": "autoMapInputData",
        "inputsToIgnore": "error"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [832, 1072],
      "id": "6f8a1433-3613-4018-8f9a-4676d7b30ec2",
      "name": "update_cache_search_results",
      "credentials": {
        "supabaseApi": {
          "id": "NabDZqnQNq4nPLYM",
          "name": "supabase_anon_key"
        }
      },
      "onError": "continueErrorOutput"
    }
  ],
  "pinData": {},
  "connections": {
    "chat_agent": {
      "main": [
        [
          {
            "node": "normalize_output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gpt_4.1_mini": {
      "ai_languageModel": [
        [
          {
            "node": "chat_agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "gpt_4.1_full": {
      "ai_languageModel": [
        [
          {
            "node": "chat_agent",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "respond_to_chat": {
      "main": [[]]
    },
    "hosted_chat_trigger": {
      "main": [
        [
          {
            "node": "chat_agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "call_google_serp": {
      "ai_tool": [
        [
          {
            "node": "chat_agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "assign_sessionId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "search_cache": {
      "ai_tool": [
        [
          {
            "node": "chat_agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "agent_memory": {
      "ai_memory": [
        [
          {
            "node": "chat_agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "assign_sessionId": {
      "main": [[]]
    },
    "normalize_output": {
      "main": [
        [
          {
            "node": "update_cache_search_results",
            "type": "main",
            "index": 0
          },
          {
            "node": "send_off_whispers_in_the_ether",
            "type": "main",
            "index": 0
          },
          {
            "node": "pretty_print_results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "call_discord_error_notifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "pretty_print_results": {
      "main": [
        [
          {
            "node": "respond_to_chat",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "call_discord_error_notifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "send_off_whispers_in_the_ether": {
      "main": [
        [],
        [
          {
            "node": "call_discord_error_notifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "update_cache_search_results": {
      "main": [
        [],
        [
          {
            "node": "call_discord_error_notifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "g0RA1ILyuSMHbt6q"
  },
  "versionId": "e263c0c5-db8e-4d97-ade7-f48b1a981b91",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ca38a51753a4eaa26e21803b676daa6c69ce9542656c83ba5959cacf3a748990"
  },
  "id": "Yogrk8C57eV2wMpk",
  "tags": [
    {
      "createdAt": "2025-08-29T04:02:35.168Z",
      "updatedAt": "2025-08-29T04:02:35.168Z",
      "id": "4g2r1ALvxirC7hxK",
      "name": "n8nbrightdatachallenge"
    },
    {
      "createdAt": "2025-08-29T04:02:50.893Z",
      "updatedAt": "2025-08-29T04:02:50.893Z",
      "id": "Mx3hjhTFNPLHvKnk",
      "name": "devchallenge"
    }
  ]
}
